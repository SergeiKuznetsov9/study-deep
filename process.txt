При том что есть сейчас, css внедряется прямо в js файлы сборки. Отдельных файлов стидей
вебпак не создает. Для исправления этого существует miniCSSExtractPlugin

npm i -D mini-css-extract-plugin

Далее добавляем плагин и меняем лоудер в соответствии с документацией 

Однако в режиме разработки нам не нужны отдельные файлы css. Поэтому сдпелаем так, чтобы 
этот лоудер работал только в режиме прода

Далее добавим модуль css. Для этого нужно добавить конфигурацию лоудера css. Так, лоудеры можно
добавилять не только строкой, но и объектом. В таком случае в поле options можно добавилять
настройки. Вот так:

      {
        loader: "css-loader",
        options: {
          module: true,
        },
      },

Однако после данной настройки мы все равно не сможем использовать css module. Т.к. вебпак не
будет понимать что мы хотим импортровать из css.module файлов

Для того чтобы подсказать какой тип будет импортироваться из модуль-css файлов, необходимо
создать файл с настройками global.d.ts - глобальная декларация типов.

Декларация глобального типа также приведет к тому, что названия классов, содержащихся в
CSS будут доступны для автозаполнения (в данном проекте почему то нет)

Далее создадим App.tsx, который и будем рендерить в index.tsx. Также создадим файл
глобальных стилей index.scss. Попробуем доба какой нибудь класс и заметим, что класс
к блоку добавляется, но стили не применяются. Это потому, что уникальные имена классов
генерируются для всех файлов стилей, а не только для тех, которые содержат module.
И это нужно исправить так, чтобы модули отрабатывали только для файлов, содержащих
в названии подстроку module. Для этого более тонко настроим модули в лоудерах:

modules: {
            auto: (fileName: string) =>
              Boolean(fileName.includes(".module.scss")),
          },


Кроме того, генерируемые классы не имеют нормальных названий и это не удобно в отладке
кода, поэтому настроим и это:

localIdentName: isDev ? '[path][name]__[local]' : '[hash:base64:8]'
