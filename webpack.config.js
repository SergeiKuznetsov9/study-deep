// Позволяет более удобно работать с путями
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const webpack = require("webpack");

module.exports = {
  // При настройке в первую очередь необходимо указать точку входа.
  // метод resolve позволяет склеивать переданные ему аргументы в путь
  // __dirname - означает корень приложения
  entry: path.resolve(__dirname, "src", "index.js"),

  // Можно и при помощи объекта:
  //   ключ - название входа, значение - путь до него
  //   entry: {
  // RANDOM: path.resolve(__dirname, "src", "index.js"),
  // С такой настройкой, приложение сбилдится в файл RANDOM
  //   },

  // настройка, определяющая как будет происходить сборка
  // [name] означает, что будет динамически присваиваться какие то разные названия
  // файлам сборки. По умолчанию оно соответсвует main,
  // но это имя можно изменить и для это нужно настроить output немного по другому
  // Так, нужно указать несколько entry поинтов в настройке entry
  // [contenthash] указывается для того, чтобы файл сборки от раза к разу имел разные имена
  // это нужно для решения проблемы кэширования, когда после изменений файла сервер
  // все равно будет отдавать старый файл, т.к. его название не изменилось
  // clean: true удаляет прежние файлы сборки
  output: {
    filename: "[name].[contenthash].js",
    path: path.resolve(__dirname, "build"),
    clean: true,
  },

  // следующей настройкой задается режим сборки. Можно использовать 'production'
  mode: "development",

  // Так добавляются плагины (предварительно установить и импортнуть)
  plugins: [
    // Этот вызов создаст класс. Теперь при сборке будет создаваться еще и HTML файл,
    // И в этот HTML сразу же будет подключен наш скрипт. Если скриптов много - это очень удобно.
    // Они добавятся автоматически и нам не нужно будет следить за их порядком
    // new HtmlWebpackPlugin(),
    // Однако есть проблема. В созданный вебпаком HTML не попадет содержимое body нашего файла,
    // Поскольку html создается не из нашего файла, а самостоятельно вебпаком
    // Чтобы оно попало нужно настроить плагин
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, "public", "index.html"),
    }),

    // Позволяет наблюдать прогресс сборки
    new webpack.ProgressPlugin(),
  ],
};
